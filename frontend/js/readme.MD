# Javascript 언어
## 목적
- 전 세계 언어 top10에 속함 -> 수요가 많다
- FE 포지션에서 SPA 개발할 때 주력언어
- react 개발시 사용언어 (JavaScript, Typescript)

## 개요
- History
    - 2005년 이전
        - js는 해킹의 온상, 사용을 주저, 표준 x
    - 2005년
        - google map 등장
        - js에 `ajax`(Async Background tech, xml 대상) 도입 -> 지도서비스 개시
    - 2005년 이후
        - 2008년 Chrome 브라우저 등장, `v8` 기술 공개
        - `nodejs` 등장(2009 ~ 2010)
            - JS가 전방위 발전
            - 웹, 데스크톱 App, 모바일 개발 됨

- Version
    - ECMAScript(Javascript 공식명칭)
    - https://www.w3schools.com/js/js_versions.asp
    - 2009 : ES5, ECMAScript 5, 현재 형태로 개정
    - 2015 : `ES6`, ECMAScript 2015, 현재 기본 표준형태 -> `ES Next`
    - 2015 이후 : 매년 문법이 추가되어서 ECMA에서 발표

- JS 표현 범위
    - TS(TypeScript) > ES Next > ES5
    - 최종 작성된 JS는 ES6 기준으로 작성
        - 최신 문법에 맞게 작성 -> TransCompile -> ES6로 자동변환('babel' lib가 담당한다)

- JS의 최종 산출물
    - ES6 (모든 브라우저에서 정상적으로 작동)

## 언어 기본
- 표현식(expression)
    - 값을 생성(획득)하는 코드 단위
    - 파트, 조각
    - 문장을 완성하는 과정, 조각

- 문장(statement)
    - 작업 수행 단위
    - ;으로 끝난다. 단, JS는 생략 가능함

- 참고
    - 조각이 모여서 -> 문장이 완성
    - 문장이 모여서 -> 코드, 모듈, 함수 등 단위가 완성 -> 개발할때의 task단위

- 키워드
    - 예약어
    - 식별자로 사용 X
    - ex) function, var, let, const, if, while, ...

- 식별자(identifier)
    - 변수명, 함수명, 클래스명, 모듈명, 속성명, ...
    - 이름정의 -> 네이밍 컨벤션
    - 네이밍 컨벤션 종류 -> 전통, 문화 -> 동일하게 작성
        - 카멜 표기법
            - 시작문자
                - 문자(A-Z, a-z, 각국문자), 달러기호($), 밑줄(언더스코어, _)
            - 두번째 문자
                - 숫자 추가됨(0-9)
            - 대소문자 구분
            - 클래스명 첫글자 -> 대문자
            - 단어가 이어지면 이어지는 첫글자 -> 대문자
            - ex) _name, getName, Person(Person 클래스)
            - Java, JavaScript, ...
        - 스네이크 표기법
            - 이름 사이에 언더바(_)를 사용
                - ex) get_name, get_age_for_man
            - Python, ...
        - ...


## 타입
- NULL      -> 값이 없다
- Undefined -> 정의되지 않았다
- Boolean   -> 참, 거짓
- Number    -> 수치형 데이터(정수, 부동소수, ...)
- Bigint    -> 더 큰 범위를 가진 정수
- String    -> 문자열( "Javascript" )
- Symbol    -> 심볼
- Object    -> 객체

## 변수
- "1_var.js" 참고
- 문법
    - 변수 선언
         키워드 변수명;
    - 변수 선언
         키워드 변수명 = 값;
- 용도
    - 값을 담는 그릇 or 값을 가르키는 주소를 가진 그릇
    - 수치, 문자열, 불리언 등 특정 타입의 데이터를 담는 그릇
- 키워드
    - var
        - 초기부터 게속 사용
        - 버그문제가 내제되어 있음
    - 표현 추가
        - 변수의 범위를 블록 스코프( { 여기서만 유효 } )
        - let
            - 변수
        - const
            - 상수 : 값을 한번 세팅하면 바꿀수 없다
            - 상수명은 통상적으로 대문자와 언더바(_)로만 표현
            - 환경변수, 설정값, CONFIG용도

## 문자열
- "2_string.js" 참고
- 표현 
    - '문자열'
    - "문자열"
    - ESNext 추가 (백틱 표현)
        - 템플릿 문자열 처리
        - `문자열` <-> 파이썬:'''...''' or """ ... """
        - 동적으로 문자열 구성 획기적 발전(포멧팅)
        - `${ 값 } ${ 값 }` <- 포매팅 가능

## 연산자
- "3_operator.js" 참고
- 산술, 비교, ....
- 기본적인 연산자 확인후, 필요시 추가
- 연산자 우선순위 -> (  ) 가장먼저 수행된다!!

## 형변환
- "4_typecasting.js" 참고
- 타입 변환
- 종류
    - 명시적 형변환
        - 직접코드로 표현 -> 타입명의 함수를 활용
        - String( param ), Number( param ), ...
    - 암묵적 형변환

## 흐름제어 : 조건문, 반복문 <- 제어문
- "5_flowcontrol_if.js" 참고
- "6_flowcontrol_loop.js" 참고
- 조건문
    - 현재까지의 기존코드 -> line 1.수행, line 2.수행, ... , line n.수행
    - 위에서 아래로 진행되는 코드의 흐름을 제어(방향 변경, 반복, 생략)
    - 조건문
        - 기본 문법
            - if ( 조건식(condition expression) ) { 수행문(statements, 참일때 수행) }
        - 조건이 여러개일때
            - if ~ else if ~ else if ~ else ~
    - 조건식
        - 결과는 항상 true, false -> boolean
        - 조건식에 사용하는 연산자
            - 비교연산자
                - <, >, , <=, >= ==, !=
                - ===, !==
            - 논리연산자
                - A && B (and) : A, B 모두 true -> true
                - A || B (or) : A, B 둘 중 하나라도 true -> true
                - !A (not) : true -> false, false -> true
            - 삼항연산자
                조건식 ? 참일때 값 : 거짓일때 값()
            - 기타 (차후체크)
                - 논리적 할당 연산자
                    - &&=, ||=, ??=
                - 비트 연산자
                    - &, |, ^, ~, <<, >>, >>>
                - 배열에 데이터가 포함되었는지 체크 객체 체크
                    - in, instanceof
- 반복문
    - for   : 지정된 횟수를 반복
    - while : 언제끝날지 모를때 반복 (무한루프)
    - do while : 언제끝날지 모를때까지 반복, 한번은 반드시 실행해야할때
    - 기타
        - 배열, 객체 등 특정요소의 반복 처리 함수
    - 목적
        - 유사한 작업을 반복적으로 처리해야 한다면
        - 배열 등 컬렉션 데이터 쪽에서 멤버들을 하나씩 접근해서 처리할때
        - ex) 구구단, 데이터를 일괄적으로 2배 상승

- 여기까지 문법을 이용하여 프로그램 작성 -> 절차적 프로그래밍

## 함수(메소드)
- "7_function.js" 참고
- js는 최근 몇년간 함수 지향적 프로그래밍 스타일로 대부분 작성이 되고 있다
- reactjs에서 많이 보인다
- 정의
    - 특정 업무를 특정 작업단위로 묶어서 업무 처리 가능한 단위
        - ex) 로그인, 글쓰기, ...
    - 특징
        - 코드 관리 용이, 재활용성 증가, 라이브러리 작성 용이
        - 유지보수, 사용성 등의 개선
        - 반복적인 코드를 함수를 통해 표현, 재사용성의 극대화
            - 반복적인 코드 -> 함수정의
            - 반복적인 코드 사용 -> 함수 호출
    - 요소
        - input(parameter) : 외부데이터가 함수내로 진입
        - logic : 비즈니스 로직
            - ex)
                - GenAI -> GPT 추론 요청응답 -> 결과 출력
                - 로그인 -> ID, PW -> DB query -> 결과 출력
        - output : 함수내의 연산결과를 함수 밖으로 전달
- 종류
    - 형태
        - 표준함수(기본형)
        - 익명함수(이름 X)
        - 화살표(에로우, 람다)함수 (ES Next에서 추가)
    - 용도
        - 기본함수
        - 콜백함수 (Async 처리를 위해서)
        - 값의 형태로 함수를 사용
- 문법
    - 표준함수, []는 생략 가능
        ``` js
        function 함수명 ( [param, ...] ) {
            [statements ...]
            [return [value]]
        }
        ```
        - 입력시 받는 param은 매개변수(Parameter)라고 한다
        - 함수 호출시 함수에 실제로 입력되는 값은 인자(Argument)라고 한다
    - 익명함수
        - 표준함수에서 이름이 생략
        - 표현식으로 표현
        - 함수의 인자로 사용 -> 콜백함수
            ``` js
            변수키워드 변수명 = function ([param, ... ]) {
                [statements ...]
                [return [value]]
            }
            ```
    - 화살표(에로우, 람다) 함수
        - ES Next에서 추가된 내용
        - 함수를 매우 간결하게 표현
        - 규칙(표준함수를 화살표함수로 변환)
            1. function 생략
            2. 함수명 생략 -> 익명함수
            3. () : 매개변수 1개면 생략가능, 없거나 2개 이상이면 무조건 사용
            4. => : 화살표 추가
            5. {} : statement가 1개이고, 리턴값이 존재하면 생략가능함, return도 생략가능
        - 가장 짧은 함수를 표현
            ``` js
            ()=>{}
            ```

- 매개변수(Parameter)
    - 함수를 호출할때, 데이터를 전달하는 채널로 이해(함수 내부로 전달)
    - parameter 없이 함수를 호출하면 에러가 나진 않지만 초기화가 되진 않는다
    - default 값을 설정해서 추후 생길수 있는 에러를 대비
        - 타입, 기본값, 중요값 표시 가능
        - parameter가 순서대로 들어가기 때문에 반드시 앞에서 부터 입력

## 배열
- "8_array.js" 참고
- JS내부에서 정의된 특수 객체
- js, react에서 자주 사용(통신결과)
- 데이터 유형(타입기준)
    - 단일형
        - number, string, boolean, ...
        - 값 1개가 타입 1개를 대변함
    - n개의 값이 모여서 구성된 타입(객체)
        - 연속형
            - 배열
                - []
                - 샘플 : [1, 2, 3 ,5, 10, 55]
                - 각 데이터의 의미가 애매함 -> 순서가 존재 -> index
            - 컬렉션(키:값의 집합)
                - 객체 (객체 리터럴)
                - {}
                - 샘플 : {name:"kyeongbin", age:25}
                - 각 데이터의 의미가 표현됨 -> name, age 등 -> key (순서 X, key값으로 구별)


## 객체
- "9_object.js" 참고
- "10_class.js" 참고
- 최신문법(ES Next이후)에서 클래스 표기법이 추가됨
- 타 언어의 객체와 비슷하지만 다른점이 존재
- OOP 스타일을 따르지만 실제로는 다르다
- 데이터 형식을 표방한다(키:값의 조합) -> JSON과 매칭된다 -> {}
- 객체 : 키:값을 여러개 가진 컬렉션 타입
    - 데이터간 서열 X
    - 클래스 형태를 표방, 객체 지향을 모방하기 때문에 객체지향 스타일을 지향함
        - inheritance, overriding, overloading, constructor, member ... 
    - {}로 표현
    - JS의 객체 생성 방식 -> 5가지
        1. object literal
        2. object 확장
        3. constructor
        4. constructor + prototype 확장 방식
        5. 클래스로 구현하는 방식
            - ES Next에서 추가됨
            - 초창기 5년간 react 개발시 주력으로 사용 -> 현재는 거의 X, 현재는 거의 함수형
                - react에 훅이 추가되면서 함수형에서도 class형의 기능들을 대체할 수 있게 됨
            - 생성자 + 프로토타입 방식을 일반적인 클래스 형식에 도입하여 이용
    - 이 세상에 존재하는 모든 유/무형의 존재를 Entity
        - 유형 : 자동차, 사람, 컴퓨터, ...
        - 무형 : 개념, 주의, ...
    - Entity를 프로그램 세상에서 표현하기 위해서 문법적 방식을 제공 -> 클래스
        - class 문법을 이용해 Entity 코드로 표현한 것
    - 객체는 class로 작성한 내용을 메모리에 띄우면 -> 객체
        - 여러번 생성 가능
        - 객체는 메모리상에 주소를 가진다
        - 특정변수가 이 메모리상에 객체를 참조하면 이 변수는 객체를 참조하는 변수라고 부른다(참조형 변수)
            ```js
            // a는 가리키는 대상이 바뀌었을뿐이다.
            // a의 타입은 가리키는 대상에 따라 결정된다 -> 타입 추론형
            let a = 10
            a = "hi"
            ```


## 최신문법
- 코드의 효율성을 극대화 하기 위해 사용
- ES Next 기준, ES6 이후
- 비구조화 할당
    - 배열의 비구조화 할당, 배열 분해
        - "11_unstructure_array.js" 참고
        - 배열의 데이터를 접글할때 효율적으로 처리하는 전략
    - 객체의 비구조화 할당, 객체 분해
        - "12_unstructure_object.js" 참고
        - JSON으로 전달받은 데이터 JS에서 객체로 받을 수 있다.
            - JSON == JS의 객체
        - JS 객체 내부에 존재하는 데이털르 추출하는 기법
- 스프레드 연산
    - "13_spread_oper.js" 참고
    - 깊은복사(주용도)
    - 기호
        - ...변수명(배열, 객체)
- Async 처리
    - "14_async_promise.js" 참고
    - 콜백헬 문제, promise 패턴, async ~ await, generator, ...
    - JS의 실행 환경
        - 현재 nodejs 기반에서 JS를 가동중
        - nodejs의 특징
            - `single thread` 기반으로 작동
                - thread -> process를 쪼갠 작업단위
                - 강력한 퍼포먼스 발휘 -> v8 엔진 -> chrome의 기본엔진
            - 'non-blocking' 성질을 가짐
                - 코드가 진행될때, 결과를 기다리면서 대기하는 부분이 없음
                - 결과가 꼬일수 있음 -> 비동기(Asynchronized)식 코드 <-> 동기(Synchronized)식 코드
                - 참고
                    - Sync
                        - Python -> 느림
                    - Async
                        - JavaScript(nodejs기반) -> 빠름 -> 순서맞추기 필요
                        - callback function으로 해결 -> async를 sync로 조절
    - Async 상황 발생 요인
        - I/O 상황이 대부분
            - 코드 <-> 외부리소스간 통신시
                - 외부리소스 : DB, Network, file, ... 코드 바깥쪽 자원
    - File I/O
        - js <-> file : 연결 -> 읽고/쓰기 진행 -> 닫기
        - js가 file을 엑세스 -> 외부라이브러리 사용 -> 라이브러리 import표현
        - nodejs에서는 2가지 방식 지원(라이브러리 import)
            1. CommonJS(CJS) -> 초기 nodeis부터 지원, 여전히 사용가능
            2. ES Module(ESM) -> ES Next에 의해 추가됨, react/vue 등 사용
- 연산시 null/undefined에 대한 오류대비 처리
    - "15_nullSafe.js" 참고
    - nullSafe, ...
    - 코드실행시 오류코드가 발생할 수 있다 -> 방지코드
    - ?.
        - 비동기처리시 -> 함수().then().then(). ... -> optional chaining
        - ex) 함수()?.then()?.then() -> 안전하게 처리가능 -> 중단되지 않게
    - ??
        - Nullish Coalescing
        - Null일때의 방어코드 -> 선택적 값 선택 유도
- 예외처리
    - "16_exception.js" 참고
    - S/W는 기본적으로 중단되면 안 됨
    - I/O 사용하는 코드 -> 예외처리 해주자
    - 오류발생
        - 오류를 잡는다(catch)
            - try ~ catch ~ finally
            - try : 에러가 날 것 같은 코드를 포함시키기
            - catch : try에서 에러가 난 경우 실행
            - finally : 언제나 실행
        - 오류를 던진다(throw)
            - throws ErrorObject